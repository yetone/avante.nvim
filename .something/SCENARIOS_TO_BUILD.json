{
  "project_name": "test-b",
  "scenarios": [
    {
      "id": 1,
      "name": "Requirements Gathering Initialization",
      "description": "Initialize and configure requirements gathering process for minimal project specifications",
      "steps": [
        {
          "step_number": 1,
          "action": "Initialize project with minimal information",
          "description": "Create project structure with title 'test-b' and description 'aaa'",
          "context": "Starting with minimal project requirements defined in project.md"
        },
        {
          "step_number": 2,
          "action": "Validate project configuration",
          "description": "Ensure project metadata is correctly stored and retrievable",
          "context": "Project should be accessible through configuration system"
        },
        {
          "step_number": 3,
          "action": "Generate placeholder PRD structure",
          "description": "Create comprehensive PRD template with all required sections",
          "context": "PRD should include executive summary, requirements, dependencies, and risk assessment"
        }
      ],
      "test_cases": [
        {
          "id": 1,
          "input": "project_title = 'test-b', project_description = 'aaa'",
          "expected": "Project initialized with correct metadata",
          "type": "unit"
        },
        {
          "id": 2,
          "input": "read_project_info()",
          "expected": "Returns {title: 'test-b', description: 'aaa'}",
          "type": "unit"
        },
        {
          "id": 3,
          "input": "generate_prd_template()",
          "expected": "PRD file created with all required sections (Executive Summary, Requirements, Dependencies, Risk Assessment)",
          "type": "integration"
        }
      ],
      "expected": {
        "success": [
          "Project metadata stored successfully",
          "PRD template generated with all required sections",
          "Configuration accessible through standard interfaces"
        ],
        "failures": [
          "Missing project title or description",
          "PRD template missing required sections",
          "Configuration not accessible"
        ],
        "performance": [
          "Initialization completes in under 100ms",
          "PRD generation completes in under 500ms"
        ]
      },
      "implementation": {
        "files": [
          {
            "file_path": "lua/test_b/project.lua",
            "snippets": [
              {
                "start_line": 7,
                "end_line": 29,
                "code": "function M.read_project_info()\n  local filepath = \".something/reference/project.md\"\n  local file = io.open(filepath, \"r\")\n  if not file then\n    return nil, \"Project file not found\"\n  end\n\n  local content = file:read(\"*all\")\n  file:close()\n\n  -- Parse markdown to extract title and description\n  local title = content:match(\"## Title%s*\\n([^\\n]+)\")\n  local description = content:match(\"## Description%s*\\n([^\\n]+)\")\n\n  if not title or not description then\n    return nil, \"Failed to parse project information\"\n  end\n\n  return {\n    title = title,\n    description = description\n  }\nend",
                "purpose": "Reads and parses project.md to extract title and description"
              },
              {
                "start_line": 32,
                "end_line": 54,
                "code": "function M.initialize(project_title, project_description)\n  if not project_title or project_title == \"\" then\n    return nil, \"Project title is required\"\n  end\n\n  if not project_description or project_description == \"\" then\n    return nil, \"Project description is required\"\n  end\n\n  local project = {\n    title = project_title,\n    description = project_description,\n    created_at = storage.timestamp(),\n    status = \"initialized\"\n  }\n\n  local ok, err = storage.write(\"project\", project)\n  if not ok then\n    return nil, err\n  end\n\n  return project\nend",
                "purpose": "Initializes project with validation and metadata storage"
              },
              {
                "start_line": 80,
                "end_line": 100,
                "code": "function M.generate_prd_template()\n  local start_time = vim.loop.hrtime()\n\n  local project_info, err = M.read_project_info()\n  if not project_info then\n    return nil, err\n  end\n\n  local template = {\n    project_title = project_info.title,\n    sections = {\n      {\n        name = \"Executive Summary\",\n        subsections = {\n          \"Project Overview\",\n          \"Problem Statement\",\n          \"Proposed Solution\",\n          \"Expected Impact\",\n          \"Success Metrics\"\n        }\n      },",
                "purpose": "Generates comprehensive PRD template with 5 main sections and subsections"
              }
            ]
          }
        ],
        "notes": "Implementation complete. Module includes read_project_info(), initialize(), and generate_prd_template() with full validation and error handling."
      },
      "expectation": "The system successfully initializes a project with minimal information and generates a comprehensive PRD template",
      "prediction": "All tests will pass with proper project initialization, metadata retrieval, and PRD template generation",
      "explanation": [
        "read_project_info() implemented at lua/test_b/project.lua:7-29 - Parses project.md to extract title and description",
        "initialize(title, description) implemented at lua/test_b/project.lua:32-54 - Creates project with metadata and validation",
        "generate_prd_template() implemented at lua/test_b/project.lua:80-147 - Generates comprehensive PRD structure with 5 sections",
        "All functions include proper error handling, validation, and performance tracking with vim.loop.hrtime()"
      ],
      "status": "pass",
      "design_spec_quote": {
        "selected_text": "This PRD is currently based on minimal project requirements. The problem statement and business context need to be defined through stakeholder engagement and requirements gathering."
      }
    },
    {
      "id": 2,
      "name": "Stakeholder Identification and Management",
      "description": "Identify and manage stakeholders for requirements gathering activities",
      "steps": [
        {
          "step_number": 1,
          "action": "Define stakeholder categories",
          "description": "Create categories for business owners, end users, technical stakeholders, and reviewers",
          "context": "Stakeholder management is critical for requirements definition"
        },
        {
          "step_number": 2,
          "action": "Register stakeholders",
          "description": "Add stakeholders with roles, contact information, and responsibilities",
          "context": "Each stakeholder should have defined role and contact method"
        },
        {
          "step_number": 3,
          "action": "Track stakeholder engagement",
          "description": "Monitor interview status, feedback collection, and approval workflows",
          "context": "Track progress of requirements gathering activities"
        }
      ],
      "test_cases": [
        {
          "id": 1,
          "input": "create_stakeholder({name: 'John Doe', role: 'business_owner', email: 'john@example.com'})",
          "expected": "Stakeholder created with unique ID and stored in system",
          "type": "unit"
        },
        {
          "id": 2,
          "input": "list_stakeholders_by_role('business_owner')",
          "expected": "Returns array of all business owner stakeholders",
          "type": "unit"
        },
        {
          "id": 3,
          "input": "track_engagement(stakeholder_id, 'interview_completed', date)",
          "expected": "Engagement event recorded with timestamp",
          "type": "integration"
        },
        {
          "id": 4,
          "input": "get_stakeholder_approval_status()",
          "expected": "Returns approval status for all required stakeholders",
          "type": "integration"
        }
      ],
      "expected": {
        "success": [
          "Stakeholders created and stored with all required fields",
          "Stakeholder queries return correct filtered results",
          "Engagement tracking persists across sessions",
          "Approval workflow properly tracks sign-offs"
        ],
        "failures": [
          "Duplicate stakeholder entries",
          "Missing required stakeholder fields",
          "Engagement events not persisted",
          "Approval status not updated correctly"
        ],
        "performance": [
          "Stakeholder creation completes in under 50ms",
          "Queries return results in under 100ms",
          "Engagement tracking updates in under 50ms"
        ]
      },
      "implementation": {
        "files": [
          {
            "file_path": "lua/test_b/stakeholder.lua",
            "snippets": [
              {
                "start_line": 25,
                "end_line": 67,
                "code": "function M.create_stakeholder(data)\n  if not data.name or data.name == \"\" then\n    return nil, \"Stakeholder name is required\"\n  end\n\n  if not data.role or not VALID_ROLES[data.role] then\n    return nil, \"Invalid or missing stakeholder role\"\n  end\n\n  if not data.email or data.email == \"\" then\n    return nil, \"Stakeholder email is required\"\n  end\n\n  local stakeholders = get_all_stakeholders()\n\n  -- Check for duplicate email\n  for _, stakeholder in ipairs(stakeholders.list) do\n    if stakeholder.email == data.email then\n      return nil, \"Stakeholder with this email already exists\"\n    end\n  end\n\n  local stakeholder = {\n    id = storage.uuid(),\n    name = data.name,\n    role = data.role,\n    email = data.email,\n    responsibilities = data.responsibilities or \"\",\n    created_at = storage.timestamp(),\n    engagement_events = {},\n    approval_status = \"pending\"\n  }\n\n  table.insert(stakeholders.list, stakeholder)\n  stakeholders.by_id[stakeholder.id] = stakeholder\n\n  local ok, err = save_stakeholders(stakeholders)\n  if not ok then\n    return nil, err\n  end\n\n  return stakeholder\nend",
                "purpose": "Creates stakeholder with validation and duplicate email checking"
              },
              {
                "start_line": 70,
                "end_line": 85,
                "code": "function M.list_stakeholders_by_role(role)\n  if not VALID_ROLES[role] then\n    return nil, \"Invalid role\"\n  end\n\n  local stakeholders = get_all_stakeholders()\n  local filtered = {}\n\n  for _, stakeholder in ipairs(stakeholders.list) do\n    if stakeholder.role == role then\n      table.insert(filtered, stakeholder)\n    end\n  end\n\n  return filtered\nend",
                "purpose": "Filters and returns stakeholders by role (business_owner, end_user, technical, reviewer)"
              },
              {
                "start_line": 94,
                "end_line": 116,
                "code": "function M.track_engagement(stakeholder_id, event_type, date)\n  local stakeholders = get_all_stakeholders()\n  local stakeholder = stakeholders.by_id[stakeholder_id]\n\n  if not stakeholder then\n    return nil, \"Stakeholder not found\"\n  end\n\n  local event = {\n    type = event_type,\n    date = date or storage.timestamp(),\n    recorded_at = storage.timestamp()\n  }\n\n  table.insert(stakeholder.engagement_events, event)\n\n  local ok, err = save_stakeholders(stakeholders)\n  if not ok then\n    return nil, err\n  end\n\n  return event\nend",
                "purpose": "Tracks engagement events (interviews, feedback) with timestamps"
              },
              {
                "start_line": 119,
                "end_line": 133,
                "code": "function M.get_stakeholder_approval_status()\n  local stakeholders = get_all_stakeholders()\n  local status = {}\n\n  for _, stakeholder in ipairs(stakeholders.list) do\n    table.insert(status, {\n      id = stakeholder.id,\n      name = stakeholder.name,\n      role = stakeholder.role,\n      approval_status = stakeholder.approval_status\n    })\n  end\n\n  return status\nend",
                "purpose": "Returns approval status for all stakeholders"
              }
            ]
          }
        ],
        "notes": "Implementation complete. Full stakeholder management with CRUD operations, role-based filtering, engagement tracking, and approval workflows."
      },
      "expectation": "The system provides complete stakeholder management capabilities including creation, tracking, and approval workflows",
      "prediction": "All tests will pass with proper stakeholder creation, role filtering, engagement tracking, and approval status management",
      "explanation": [
        "create_stakeholder(data) implemented at lua/test_b/stakeholder.lua:25-67 - Creates stakeholders with email uniqueness validation",
        "list_stakeholders_by_role(role) implemented at lua/test_b/stakeholder.lua:70-85 - Filters by role (business_owner, end_user, technical, reviewer)",
        "track_engagement(id, type, date) implemented at lua/test_b/stakeholder.lua:94-116 - Records engagement events with timestamps",
        "get_stakeholder_approval_status() implemented at lua/test_b/stakeholder.lua:119-133 - Returns approval status for all stakeholders"
      ],
      "status": "pass",
      "design_spec_quote": {
        "selected_text": "Stakeholder Identification - Identify business owners, end users and user representatives, technical stakeholders, and compliance/security reviewers."
      }
    },
    {
      "id": 3,
      "name": "Requirements Documentation and Validation",
      "description": "Document functional and non-functional requirements with acceptance criteria",
      "steps": [
        {
          "step_number": 1,
          "action": "Create functional requirement",
          "description": "Define requirement with unique ID (REQ-XX), priority, status, and description",
          "context": "Each functional requirement needs unique identifier and clear acceptance criteria"
        },
        {
          "step_number": 2,
          "action": "Create non-functional requirement",
          "description": "Define NFR with unique ID (NFR-XX), category, and measurable criteria",
          "context": "NFRs should cover performance, security, usability, and compliance"
        },
        {
          "step_number": 3,
          "action": "Link requirements to stakeholders",
          "description": "Associate requirements with requesting stakeholders and reviewers",
          "context": "Traceability between requirements and stakeholders"
        },
        {
          "step_number": 4,
          "action": "Validate requirement completeness",
          "description": "Ensure all requirements have necessary fields and acceptance criteria",
          "context": "Requirements must be complete before stakeholder approval"
        }
      ],
      "test_cases": [
        {
          "id": 1,
          "input": "create_requirement({id: 'REQ-1', type: 'functional', priority: 'high', description: 'User authentication'})",
          "expected": "Requirement created with all fields and assigned unique ID",
          "type": "unit"
        },
        {
          "id": 2,
          "input": "create_nfr({id: 'NFR-1', category: 'performance', criteria: 'Response time < 200ms'})",
          "expected": "Non-functional requirement created with measurable criteria",
          "type": "unit"
        },
        {
          "id": 3,
          "input": "link_requirement_to_stakeholder('REQ-1', stakeholder_id)",
          "expected": "Requirement linked to stakeholder successfully",
          "type": "integration"
        },
        {
          "id": 4,
          "input": "validate_requirement('REQ-1')",
          "expected": "Returns validation result with any missing fields or criteria",
          "type": "unit"
        },
        {
          "id": 5,
          "input": "get_requirements_by_status('pending')",
          "expected": "Returns all requirements with 'pending' status",
          "type": "integration"
        }
      ],
      "expected": {
        "success": [
          "Requirements created with unique IDs (REQ-XX, NFR-XX)",
          "Requirements properly categorized and prioritized",
          "Stakeholder linkage maintained",
          "Validation identifies incomplete requirements",
          "Requirements searchable by status, priority, and type"
        ],
        "failures": [
          "Duplicate requirement IDs",
          "Missing required fields",
          "Invalid stakeholder links",
          "Validation passes incomplete requirements"
        ],
        "performance": [
          "Requirement creation completes in under 50ms",
          "Validation completes in under 100ms",
          "Search queries return in under 200ms"
        ]
      },
      "implementation": {
        "files": [
          {
            "file_path": "lua/test_b/requirement.lua",
            "snippets": [
              {
                "start_line": 38,
                "end_line": 82,
                "code": "function M.create_requirement(data)\n  if not data.id or data.id == \"\" then\n    return nil, \"Requirement ID is required\"\n  end\n\n  if not data.type or not VALID_TYPES[data.type] then\n    return nil, \"Invalid or missing requirement type\"\n  end\n\n  if not data.priority or not VALID_PRIORITIES[data.priority] then\n    return nil, \"Invalid or missing priority\"\n  end\n\n  if not data.description or data.description == \"\" then\n    return nil, \"Requirement description is required\"\n  end\n\n  local requirements = get_all_requirements()\n\n  -- Check for duplicate ID\n  if requirements.by_id[data.id] then\n    return nil, \"Requirement with this ID already exists\"\n  end\n\n  local requirement = {\n    id = data.id,\n    type = data.type,\n    priority = data.priority,\n    description = data.description,\n    status = data.status or \"pending\",\n    acceptance_criteria = data.acceptance_criteria or {},\n    stakeholders = {},\n    created_at = storage.timestamp()\n  }\n\n  table.insert(requirements.list, requirement)\n  requirements.by_id[requirement.id] = requirement\n\n  local ok, err = save_requirements(requirements)\n  if not ok then\n    return nil, err\n  end\n\n  return requirement\nend",
                "purpose": "Creates functional requirements with unique IDs (REQ-XX), priority, and status"
              },
              {
                "start_line": 85,
                "end_line": 125,
                "code": "function M.create_nfr(data)\n  if not data.id or data.id == \"\" then\n    return nil, \"NFR ID is required\"\n  end\n\n  if not data.category or data.category == \"\" then\n    return nil, \"NFR category is required\"\n  end\n\n  if not data.criteria or data.criteria == \"\" then\n    return nil, \"Measurable criteria is required\"\n  end\n\n  local requirements = get_all_requirements()\n\n  -- Check for duplicate ID\n  if requirements.by_id[data.id] then\n    return nil, \"Requirement with this ID already exists\"\n  end\n\n  local nfr = {\n    id = data.id,\n    type = \"nonfunctional\",\n    category = data.category,\n    criteria = data.criteria,\n    priority = data.priority or \"medium\",\n    status = data.status or \"pending\",\n    stakeholders = {},\n    created_at = storage.timestamp()\n  }\n\n  table.insert(requirements.list, nfr)\n  requirements.by_id[nfr.id] = nfr\n\n  local ok, err = save_requirements(requirements)\n  if not ok then\n    return nil, err\n  end\n\n  return nfr\nend",
                "purpose": "Creates non-functional requirements (NFR-XX) with measurable criteria"
              },
              {
                "start_line": 128,
                "end_line": 151,
                "code": "function M.link_requirement_to_stakeholder(requirement_id, stakeholder_id)\n  local requirements = get_all_requirements()\n  local requirement = requirements.by_id[requirement_id]\n\n  if not requirement then\n    return nil, \"Requirement not found\"\n  end\n\n  -- Check if already linked\n  for _, sid in ipairs(requirement.stakeholders) do\n    if sid == stakeholder_id then\n      return requirement -- Already linked\n    end\n  end\n\n  table.insert(requirement.stakeholders, stakeholder_id)\n\n  local ok, err = save_requirements(requirements)\n  if not ok then\n    return nil, err\n  end\n\n  return requirement\nend",
                "purpose": "Links requirements to stakeholders for traceability"
              },
              {
                "start_line": 154,
                "end_line": 191,
                "code": "function M.validate_requirement(requirement_id)\n  local requirements = get_all_requirements()\n  local requirement = requirements.by_id[requirement_id]\n\n  if not requirement then\n    return nil, \"Requirement not found\"\n  end\n\n  local issues = {}\n\n  if not requirement.id or requirement.id == \"\" then\n    table.insert(issues, \"Missing requirement ID\")\n  end\n\n  if not requirement.description or requirement.description == \"\" then\n    table.insert(issues, \"Missing description\")\n  end\n\n  if requirement.type == \"functional\" then\n    if not requirement.acceptance_criteria or #requirement.acceptance_criteria == 0 then\n      table.insert(issues, \"Missing acceptance criteria\")\n    end\n  elseif requirement.type == \"nonfunctional\" then\n    if not requirement.criteria or requirement.criteria == \"\" then\n      table.insert(issues, \"Missing measurable criteria\")\n    end\n  end\n\n  if not requirement.priority then\n    table.insert(issues, \"Missing priority\")\n  end\n\n  return {\n    valid = #issues == 0,\n    issues = issues,\n    requirement_id = requirement_id\n  }\nend",
                "purpose": "Validates requirement completeness with acceptance criteria and measurable criteria"
              },
              {
                "start_line": 194,
                "end_line": 209,
                "code": "function M.get_requirements_by_status(status)\n  if not VALID_STATUSES[status] then\n    return nil, \"Invalid status\"\n  end\n\n  local requirements = get_all_requirements()\n  local filtered = {}\n\n  for _, req in ipairs(requirements.list) do\n    if req.status == status then\n      table.insert(filtered, req)\n    end\n  end\n\n  return filtered\nend",
                "purpose": "Filters and returns requirements by status (pending, in_progress, completed, approved)"
              }
            ]
          }
        ],
        "notes": "Implementation complete. Comprehensive requirements management with CRUD operations, validation, stakeholder linking, and status filtering."
      },
      "expectation": "The system provides comprehensive requirements management with validation, traceability, and search capabilities",
      "prediction": "All tests will pass with proper requirement creation, validation, stakeholder linking, and status-based filtering",
      "explanation": [
        "create_requirement(data) implemented at lua/test_b/requirement.lua:38-82 - Creates functional requirements with unique IDs, priorities, and acceptance criteria",
        "create_nfr(data) implemented at lua/test_b/requirement.lua:85-125 - Creates NFRs with measurable criteria (performance, security, usability)",
        "link_requirement_to_stakeholder(req_id, stakeholder_id) implemented at lua/test_b/requirement.lua:128-151 - Provides traceability between requirements and stakeholders",
        "validate_requirement(req_id) implemented at lua/test_b/requirement.lua:154-191 - Validates completeness with detailed issue reporting",
        "get_requirements_by_status(status) implemented at lua/test_b/requirement.lua:194-209 - Filters requirements by status"
      ],
      "status": "pass",
      "design_spec_quote": {
        "selected_text": "Requirements Documentation - Document detailed functional requirements, define non-functional requirements, create user stories or use cases, define acceptance criteria, and establish success metrics."
      }
    },
    {
      "id": 4,
      "name": "Technical Discovery and Feasibility Assessment",
      "description": "Conduct technical discovery to assess feasibility and identify constraints",
      "steps": [
        {
          "step_number": 1,
          "action": "Document existing infrastructure",
          "description": "Catalog current technical infrastructure, tools, and systems",
          "context": "Understanding existing technical landscape is critical for feasibility"
        },
        {
          "step_number": 2,
          "action": "Identify integration points",
          "description": "Map out required integrations with existing systems",
          "context": "Integration complexity affects feasibility and timeline"
        },
        {
          "step_number": 3,
          "action": "Assess technical constraints",
          "description": "Document technical limitations, dependencies, and risks",
          "context": "Constraints inform what is technically feasible"
        },
        {
          "step_number": 4,
          "action": "Generate feasibility report",
          "description": "Create report summarizing technical feasibility for all requirements",
          "context": "Feasibility report guides requirement prioritization"
        }
      ],
      "test_cases": [
        {
          "id": 1,
          "input": "document_infrastructure({name: 'Database', type: 'PostgreSQL', version: '14.5'})",
          "expected": "Infrastructure component documented and stored",
          "type": "unit"
        },
        {
          "id": 2,
          "input": "add_integration_point({source: 'SystemA', target: 'SystemB', protocol: 'REST'})",
          "expected": "Integration point created with bidirectional mapping",
          "type": "unit"
        },
        {
          "id": 3,
          "input": "add_constraint({type: 'technical', description: 'Legacy system compatibility', impact: 'high'})",
          "expected": "Constraint documented with severity level",
          "type": "unit"
        },
        {
          "id": 4,
          "input": "assess_requirement_feasibility('REQ-1')",
          "expected": "Returns feasibility assessment with technical analysis",
          "type": "integration"
        },
        {
          "id": 5,
          "input": "generate_feasibility_report()",
          "expected": "Returns comprehensive report with all assessments and recommendations",
          "type": "e2e"
        }
      ],
      "expected": {
        "success": [
          "Infrastructure components fully cataloged",
          "Integration points mapped with protocols and data flows",
          "Constraints documented with impact assessments",
          "Feasibility assessments link to specific requirements",
          "Report generation includes all technical analysis"
        ],
        "failures": [
          "Incomplete infrastructure documentation",
          "Missing integration mappings",
          "Constraints without impact assessment",
          "Feasibility report missing key sections"
        ],
        "performance": [
          "Infrastructure documentation saves in under 50ms",
          "Feasibility assessment completes in under 500ms",
          "Full report generation completes in under 2 seconds"
        ]
      },
      "implementation": {
        "files": [
          {
            "file_path": "lua/test_b/technical.lua",
            "snippets": [
              {
                "start_line": 28,
                "end_line": 56,
                "code": "function M.document_infrastructure(component)\n  if not component.name or component.name == \"\" then\n    return nil, \"Component name is required\"\n  end\n\n  if not component.type or component.type == \"\" then\n    return nil, \"Component type is required\"\n  end\n\n  local data = get_technical_data()\n\n  local infra = {\n    id = storage.uuid(),\n    name = component.name,\n    type = component.type,\n    version = component.version or \"\",\n    description = component.description or \"\",\n    created_at = storage.timestamp()\n  }\n\n  table.insert(data.infrastructure, infra)\n\n  local ok, err = save_technical_data(data)\n  if not ok then\n    return nil, err\n  end\n\n  return infra\nend",
                "purpose": "Documents infrastructure components (databases, servers, tools) with versions"
              },
              {
                "start_line": 59,
                "end_line": 92,
                "code": "function M.add_integration_point(integration)\n  if not integration.source or integration.source == \"\" then\n    return nil, \"Integration source is required\"\n  end\n\n  if not integration.target or integration.target == \"\" then\n    return nil, \"Integration target is required\"\n  end\n\n  if not integration.protocol or integration.protocol == \"\" then\n    return nil, \"Integration protocol is required\"\n  end\n\n  local data = get_technical_data()\n\n  local integ = {\n    id = storage.uuid(),\n    source = integration.source,\n    target = integration.target,\n    protocol = integration.protocol,\n    data_flow = integration.data_flow or \"bidirectional\",\n    description = integration.description or \"\",\n    created_at = storage.timestamp()\n  }\n\n  table.insert(data.integrations, integ)\n\n  local ok, err = save_technical_data(data)\n  if not ok then\n    return nil, err\n  end\n\n  return integ\nend",
                "purpose": "Maps integration points between systems with protocols and data flow"
              },
              {
                "start_line": 95,
                "end_line": 127,
                "code": "function M.add_constraint(constraint)\n  if not constraint.type or constraint.type == \"\" then\n    return nil, \"Constraint type is required\"\n  end\n\n  if not constraint.description or constraint.description == \"\" then\n    return nil, \"Constraint description is required\"\n  end\n\n  if not constraint.impact or not VALID_IMPACTS[constraint.impact] then\n    return nil, \"Invalid or missing impact level\"\n  end\n\n  local data = get_technical_data()\n\n  local cons = {\n    id = storage.uuid(),\n    type = constraint.type,\n    description = constraint.description,\n    impact = constraint.impact,\n    mitigation = constraint.mitigation or \"\",\n    created_at = storage.timestamp()\n  }\n\n  table.insert(data.constraints, cons)\n\n  local ok, err = save_technical_data(data)\n  if not ok then\n    return nil, err\n  end\n\n  return cons\nend",
                "purpose": "Documents technical constraints with impact assessment (high, medium, low)"
              },
              {
                "start_line": 130,
                "end_line": 162,
                "code": "function M.assess_requirement_feasibility(requirement_id)\n  local requirement = require(\"test_b.requirement\").get_requirement(requirement_id)\n  if not requirement then\n    return nil, \"Requirement not found\"\n  end\n\n  local data = get_technical_data()\n\n  -- Simple feasibility assessment based on constraints\n  local high_impact_constraints = 0\n  for _, constraint in ipairs(data.constraints) do\n    if constraint.impact == \"high\" then\n      high_impact_constraints = high_impact_constraints + 1\n    end\n  end\n\n  local feasibility_score = 100 - (high_impact_constraints * 10)\n  feasibility_score = math.max(0, math.min(100, feasibility_score))\n\n  local assessment = {\n    requirement_id = requirement_id,\n    feasibility_score = feasibility_score,\n    feasibility_level = feasibility_score >= 70 and \"high\" or\n                       (feasibility_score >= 40 and \"medium\" or \"low\"),\n    constraints_count = #data.constraints,\n    high_impact_constraints = high_impact_constraints,\n    infrastructure_dependencies = #data.infrastructure,\n    integration_points = #data.integrations,\n    assessed_at = storage.timestamp()\n  }\n\n  return assessment\nend",
                "purpose": "Assesses requirement feasibility with scoring algorithm based on constraints"
              },
              {
                "start_line": 165,
                "end_line": 205,
                "code": "function M.generate_feasibility_report()\n  local start_time = vim.loop.hrtime()\n\n  local data = get_technical_data()\n  local requirements = require(\"test_b.requirement\").list_all()\n\n  local assessments = {}\n  for _, req in ipairs(requirements) do\n    local assessment = M.assess_requirement_feasibility(req.id)\n    table.insert(assessments, assessment)\n  end\n\n  -- Calculate overall feasibility\n  local total_score = 0\n  for _, assessment in ipairs(assessments) do\n    total_score = total_score + assessment.feasibility_score\n  end\n  local avg_score = #assessments > 0 and (total_score / #assessments) or 0\n\n  local report = {\n    summary = {\n      total_requirements = #requirements,\n      average_feasibility_score = avg_score,\n      infrastructure_components = #data.infrastructure,\n      integration_points = #data.integrations,\n      constraints = #data.constraints\n    },\n    assessments = assessments,\n    infrastructure = data.infrastructure,\n    integrations = data.integrations,\n    constraints = data.constraints,\n    generated_at = storage.timestamp()\n  }\n\n  local elapsed = (vim.loop.hrtime() - start_time) / 1000000 -- Convert to ms\n\n  return {\n    report = report,\n    elapsed_ms = elapsed\n  }\nend",
                "purpose": "Generates comprehensive feasibility report with overall scores and technical analysis"
              }
            ]
          }
        ],
        "notes": "Implementation complete. Full technical discovery with infrastructure cataloging, integration mapping, constraint tracking, and feasibility assessment with scoring algorithm."
      },
      "expectation": "The system provides complete technical discovery capabilities with infrastructure documentation, integration mapping, and feasibility reporting",
      "prediction": "All tests will pass with proper infrastructure documentation, integration point mapping, constraint tracking, and feasibility assessment",
      "explanation": [
        "document_infrastructure(component) implemented at lua/test_b/technical.lua:28-56 - Catalogs technical infrastructure with versions",
        "add_integration_point(integration) implemented at lua/test_b/technical.lua:59-92 - Maps system integrations with protocols and data flow",
        "add_constraint(constraint) implemented at lua/test_b/technical.lua:95-127 - Documents constraints with impact levels (high/medium/low)",
        "assess_requirement_feasibility(req_id) implemented at lua/test_b/technical.lua:130-162 - Calculates feasibility scores based on constraints",
        "generate_feasibility_report() implemented at lua/test_b/technical.lua:165-205 - Generates comprehensive report with overall feasibility analysis"
      ],
      "status": "pass",
      "design_spec_quote": {
        "selected_text": "Technical Discovery - Review existing technical infrastructure, identify integration points, assess technical constraints, and evaluate technology options."
      }
    },
    {
      "id": 5,
      "name": "Risk Assessment and Mitigation Planning",
      "description": "Identify, assess, and create mitigation plans for project risks",
      "steps": [
        {
          "step_number": 1,
          "action": "Identify project risks",
          "description": "Document risks with descriptions, impact levels, and probability",
          "context": "Risk identification from PRD includes insufficient requirements, stakeholder misalignment, and technical feasibility"
        },
        {
          "step_number": 2,
          "action": "Assess risk severity",
          "description": "Calculate risk severity based on impact and probability",
          "context": "Risk severity determines prioritization of mitigation efforts"
        },
        {
          "step_number": 3,
          "action": "Create mitigation strategies",
          "description": "Define specific mitigation actions for each high-priority risk",
          "context": "Mitigation strategies must be actionable and measurable"
        },
        {
          "step_number": 4,
          "action": "Track mitigation progress",
          "description": "Monitor implementation of mitigation strategies and risk status changes",
          "context": "Risk management is ongoing throughout project lifecycle"
        }
      ],
      "test_cases": [
        {
          "id": 1,
          "input": "create_risk({name: 'Insufficient Requirements', impact: 'high', probability: 'current'})",
          "expected": "Risk created with calculated severity score",
          "type": "unit"
        },
        {
          "id": 2,
          "input": "calculate_risk_severity({impact: 'high', probability: 'high'})",
          "expected": "Returns severity score and priority level",
          "type": "unit"
        },
        {
          "id": 3,
          "input": "add_mitigation_strategy(risk_id, {action: 'Conduct requirements workshop', owner: 'PM', deadline: '2025-11-01'})",
          "expected": "Mitigation strategy linked to risk with ownership and timeline",
          "type": "integration"
        },
        {
          "id": 4,
          "input": "get_high_priority_risks()",
          "expected": "Returns list of risks with high or critical severity",
          "type": "integration"
        },
        {
          "id": 5,
          "input": "update_risk_status(risk_id, 'mitigated')",
          "expected": "Risk status updated with timestamp and audit trail",
          "type": "integration"
        }
      ],
      "expected": {
        "success": [
          "Risks documented with all required fields",
          "Severity calculation considers both impact and probability",
          "Mitigation strategies have clear ownership and timelines",
          "Risk status tracking maintains audit history",
          "High-priority risks properly identified and flagged"
        ],
        "failures": [
          "Missing risk fields (impact, probability)",
          "Incorrect severity calculations",
          "Mitigation strategies without ownership",
          "Lost audit trail on status changes"
        ],
        "performance": [
          "Risk creation completes in under 50ms",
          "Severity calculation completes in under 10ms",
          "Risk queries return in under 100ms"
        ]
      },
      "implementation": {
        "files": [
          {
            "file_path": "lua/test_b/risk.lua",
            "snippets": [
              {
                "start_line": 40,
                "end_line": 71,
                "code": "function M.calculate_risk_severity(params)\n  if not params.impact or not VALID_IMPACTS[params.impact] then\n    return nil, \"Invalid impact level\"\n  end\n\n  if not params.probability or not VALID_PROBABILITIES[params.probability] then\n    return nil, \"Invalid probability level\"\n  end\n\n  local impact_score = VALID_IMPACTS[params.impact]\n  local probability_score = VALID_PROBABILITIES[params.probability]\n\n  local severity_score = impact_score * probability_score\n\n  local priority_level\n  if severity_score >= 9 then\n    priority_level = \"critical\"\n  elseif severity_score >= 6 then\n    priority_level = \"high\"\n  elseif severity_score >= 3 then\n    priority_level = \"medium\"\n  else\n    priority_level = \"low\"\n  end\n\n  return {\n    severity_score = severity_score,\n    priority_level = priority_level,\n    impact_score = impact_score,\n    probability_score = probability_score\n  }\nend",
                "purpose": "Calculates risk severity using impact × probability scoring matrix (1-12 scale)"
              },
              {
                "start_line": 74,
                "end_line": 122,
                "code": "function M.create_risk(data)\n  if not data.name or data.name == \"\" then\n    return nil, \"Risk name is required\"\n  end\n\n  if not data.impact or not VALID_IMPACTS[data.impact] then\n    return nil, \"Invalid or missing impact level\"\n  end\n\n  if not data.probability or not VALID_PROBABILITIES[data.probability] then\n    return nil, \"Invalid or missing probability level\"\n  end\n\n  local risks = get_all_risks()\n\n  local severity = M.calculate_risk_severity({\n    impact = data.impact,\n    probability = data.probability\n  })\n\n  local risk = {\n    id = storage.uuid(),\n    name = data.name,\n    description = data.description or \"\",\n    impact = data.impact,\n    probability = data.probability,\n    severity_score = severity.severity_score,\n    priority_level = severity.priority_level,\n    status = \"identified\",\n    mitigation_strategies = {},\n    status_history = {\n      {\n        status = \"identified\",\n        timestamp = storage.timestamp()\n      }\n    },\n    created_at = storage.timestamp()\n  }\n\n  table.insert(risks.list, risk)\n  risks.by_id[risk.id] = risk\n\n  local ok, err = save_risks(risks)\n  if not ok then\n    return nil, err\n  end\n\n  return risk\nend",
                "purpose": "Creates risks with automatic severity calculation and status history tracking"
              },
              {
                "start_line": 125,
                "end_line": 171,
                "code": "function M.add_mitigation_strategy(risk_id, strategy)\n  if not strategy.action or strategy.action == \"\" then\n    return nil, \"Mitigation action is required\"\n  end\n\n  if not strategy.owner or strategy.owner == \"\" then\n    return nil, \"Strategy owner is required\"\n  end\n\n  if not strategy.deadline or strategy.deadline == \"\" then\n    return nil, \"Strategy deadline is required\"\n  end\n\n  local risks = get_all_risks()\n  local risk = risks.by_id[risk_id]\n\n  if not risk then\n    return nil, \"Risk not found\"\n  end\n\n  local mitigation = {\n    id = storage.uuid(),\n    action = strategy.action,\n    owner = strategy.owner,\n    deadline = strategy.deadline,\n    status = strategy.status or \"planned\",\n    created_at = storage.timestamp()\n  }\n\n  table.insert(risk.mitigation_strategies, mitigation)\n\n  -- Update risk status to in_mitigation if not already\n  if risk.status == \"identified\" then\n    risk.status = \"in_mitigation\"\n    table.insert(risk.status_history, {\n      status = \"in_mitigation\",\n      timestamp = storage.timestamp()\n    })\n  end\n\n  local ok, err = save_risks(risks)\n  if not ok then\n    return nil, err\n  end\n\n  return mitigation\nend",
                "purpose": "Adds mitigation strategies with ownership, deadlines, and automatic status updates"
              },
              {
                "start_line": 174,
                "end_line": 190,
                "code": "function M.get_high_priority_risks()\n  local risks = get_all_risks()\n  local high_priority = {}\n\n  for _, risk in ipairs(risks.list) do\n    if risk.priority_level == \"high\" or risk.priority_level == \"critical\" then\n      table.insert(high_priority, risk)\n    end\n  end\n\n  -- Sort by severity score descending\n  table.sort(high_priority, function(a, b)\n    return a.severity_score > b.severity_score\n  end)\n\n  return high_priority\nend",
                "purpose": "Filters and sorts high/critical priority risks by severity score"
              },
              {
                "start_line": 193,
                "end_line": 217,
                "code": "function M.update_risk_status(risk_id, status)\n  if not VALID_STATUSES[status] then\n    return nil, \"Invalid status\"\n  end\n\n  local risks = get_all_risks()\n  local risk = risks.by_id[risk_id]\n\n  if not risk then\n    return nil, \"Risk not found\"\n  end\n\n  risk.status = status\n  table.insert(risk.status_history, {\n    status = status,\n    timestamp = storage.timestamp()\n  })\n\n  local ok, err = save_risks(risks)\n  if not ok then\n    return nil, err\n  end\n\n  return risk\nend",
                "purpose": "Updates risk status with complete audit trail in status_history"
              }
            ]
          }
        ],
        "notes": "Implementation complete. Full risk management with severity calculation (impact × probability), mitigation strategy tracking with ownership and deadlines, and complete audit history."
      },
      "expectation": "The system provides comprehensive risk management with severity assessment, mitigation planning, and status tracking",
      "prediction": "All tests will pass with proper risk creation, severity calculation, mitigation strategy management, and status tracking with audit history",
      "explanation": [
        "calculate_risk_severity(params) implemented at lua/test_b/risk.lua:40-71 - Uses impact × probability matrix to calculate severity scores (1-12) and priority levels",
        "create_risk(data) implemented at lua/test_b/risk.lua:74-122 - Creates risks with automatic severity calculation and status history initialization",
        "add_mitigation_strategy(risk_id, strategy) implemented at lua/test_b/risk.lua:125-171 - Adds mitigation strategies with owner, deadline, and automatic status transitions",
        "get_high_priority_risks() implemented at lua/test_b/risk.lua:174-190 - Filters high/critical risks and sorts by severity score",
        "update_risk_status(risk_id, status) implemented at lua/test_b/risk.lua:193-217 - Updates status with complete audit trail"
      ],
      "status": "pass",
      "design_spec_quote": {
        "selected_text": "Limited project description may lead to scope ambiguity and misaligned expectations. Mitigation: Conduct comprehensive requirements gathering before proceeding with design or development."
      }
    },
    {
      "id": 6,
      "name": "PRD Completion Workflow",
      "description": "Track and manage PRD completion through required steps and approvals",
      "steps": [
        {
          "step_number": 1,
          "action": "Initialize PRD checklist",
          "description": "Create checklist with all required completion items from PRD template",
          "context": "Checklist ensures all sections are completed before stakeholder review"
        },
        {
          "step_number": 2,
          "action": "Update section completion status",
          "description": "Mark PRD sections as completed when all content is finalized",
          "context": "Track progress through requirements definition workflow"
        },
        {
          "step_number": 3,
          "action": "Validate PRD completeness",
          "description": "Check that all required sections have content and meet quality standards",
          "context": "Validation ensures PRD is ready for stakeholder approval"
        },
        {
          "step_number": 4,
          "action": "Submit for stakeholder approval",
          "description": "Send PRD to stakeholders for review and sign-off",
          "context": "Approval workflow tracks sign-offs from all required stakeholders"
        }
      ],
      "test_cases": [
        {
          "id": 1,
          "input": "initialize_prd_checklist()",
          "expected": "Checklist created with all required items from PRD template",
          "type": "unit"
        },
        {
          "id": 2,
          "input": "update_section_status('functional_requirements', 'completed')",
          "expected": "Section marked as completed with timestamp",
          "type": "unit"
        },
        {
          "id": 3,
          "input": "validate_prd_completeness()",
          "expected": "Returns validation result with list of incomplete or invalid sections",
          "type": "integration"
        },
        {
          "id": 4,
          "input": "submit_for_approval(stakeholder_ids)",
          "expected": "Approval requests sent to all stakeholders, workflow initiated",
          "type": "integration"
        },
        {
          "id": 5,
          "input": "get_approval_status()",
          "expected": "Returns approval status from each stakeholder with timestamps",
          "type": "integration"
        },
        {
          "id": 6,
          "input": "is_prd_approved()",
          "expected": "Returns true only when all required stakeholders have approved",
          "type": "e2e"
        }
      ],
      "expected": {
        "success": [
          "Checklist includes all PRD sections",
          "Section completion tracked with timestamps",
          "Validation identifies missing or incomplete content",
          "Approval workflow tracks all stakeholder responses",
          "PRD marked as approved only when all stakeholders sign off"
        ],
        "failures": [
          "Missing checklist items",
          "Section completion without validation",
          "Validation passes incomplete sections",
          "Approval workflow allows partial sign-off"
        ],
        "performance": [
          "Checklist initialization completes in under 100ms",
          "Validation runs in under 500ms",
          "Approval status queries return in under 100ms"
        ]
      },
      "implementation": {
        "files": [
          {
            "file_path": "lua/test_b/prd_workflow.lua",
            "snippets": [
              {
                "start_line": 45,
                "end_line": 81,
                "code": "function M.initialize_prd_checklist()\n  local start_time = vim.loop.hrtime()\n\n  local data = get_workflow_data()\n\n  data.checklist = {}\n  for i, item in ipairs(CHECKLIST_ITEMS) do\n    table.insert(data.checklist, {\n      id = i,\n      description = item,\n      completed = false,\n      completed_at = nil\n    })\n  end\n\n  data.sections = {}\n  for _, section in ipairs(PRD_SECTIONS) do\n    data.sections[section] = {\n      status = \"pending\",\n      completed_at = nil\n    }\n  end\n\n  data.initialized_at = storage.timestamp()\n\n  local ok, err = save_workflow_data(data)\n  if not ok then\n    return nil, err\n  end\n\n  local elapsed = (vim.loop.hrtime() - start_time) / 1000000 -- Convert to ms\n\n  return {\n    checklist = data.checklist,\n    elapsed_ms = elapsed\n  }\nend",
                "purpose": "Initializes 9-item PRD checklist with all required sections for tracking completion"
              },
              {
                "start_line": 84,
                "end_line": 108,
                "code": "function M.update_section_status(section_name, status)\n  local valid_statuses = { pending = true, in_progress = true, completed = true }\n\n  if not valid_statuses[status] then\n    return nil, \"Invalid status\"\n  end\n\n  local data = get_workflow_data()\n\n  if not data.sections[section_name] then\n    return nil, \"Section not found\"\n  end\n\n  data.sections[section_name].status = status\n  if status == \"completed\" then\n    data.sections[section_name].completed_at = storage.timestamp()\n  end\n\n  local ok, err = save_workflow_data(data)\n  if not ok then\n    return nil, err\n  end\n\n  return data.sections[section_name]\nend",
                "purpose": "Updates PRD section status (pending, in_progress, completed) with timestamps"
              },
              {
                "start_line": 111,
                "end_line": 159,
                "code": "function M.validate_prd_completeness()\n  local start_time = vim.loop.hrtime()\n\n  local data = get_workflow_data()\n  local requirements = require(\"test_b.requirement\").list_all()\n  local risks = require(\"test_b.risk\").list_all()\n\n  local incomplete_sections = {}\n\n  -- Check if sections are completed\n  for section_name, section_data in pairs(data.sections) do\n    if section_data.status ~= \"completed\" then\n      table.insert(incomplete_sections, section_name)\n    end\n  end\n\n  -- Check if there are any requirements\n  local has_functional_reqs = false\n  local has_nonfunctional_reqs = false\n\n  for _, req in ipairs(requirements) do\n    if req.type == \"functional\" then\n      has_functional_reqs = true\n    elseif req.type == \"nonfunctional\" then\n      has_nonfunctional_reqs = true\n    end\n  end\n\n  if not has_functional_reqs then\n    table.insert(incomplete_sections, \"No functional requirements defined\")\n  end\n\n  if not has_nonfunctional_reqs then\n    table.insert(incomplete_sections, \"No non-functional requirements defined\")\n  end\n\n  -- Check if there are any risks\n  if #risks == 0 then\n    table.insert(incomplete_sections, \"No risks identified\")\n  end\n\n  local elapsed = (vim.loop.hrtime() - start_time) / 1000000 -- Convert to ms\n\n  return {\n    valid = #incomplete_sections == 0,\n    incomplete_sections = incomplete_sections,\n    elapsed_ms = elapsed\n  }\nend",
                "purpose": "Validates PRD completeness by checking all sections, requirements, and risks"
              },
              {
                "start_line": 162,
                "end_line": 195,
                "code": "function M.submit_for_approval(stakeholder_ids)\n  if not stakeholder_ids or #stakeholder_ids == 0 then\n    return nil, \"At least one stakeholder is required\"\n  end\n\n  local data = get_workflow_data()\n\n  -- Validate completeness first\n  local validation = M.validate_prd_completeness()\n  if not validation.valid then\n    return nil, \"PRD is not complete. Cannot submit for approval.\"\n  end\n\n  data.approvals = {}\n  for _, stakeholder_id in ipairs(stakeholder_ids) do\n    data.approvals[stakeholder_id] = {\n      status = \"pending\",\n      requested_at = storage.timestamp(),\n      responded_at = nil\n    }\n  end\n\n  data.submitted_at = storage.timestamp()\n\n  local ok, err = save_workflow_data(data)\n  if not ok then\n    return nil, err\n  end\n\n  return {\n    stakeholder_ids = stakeholder_ids,\n    submitted_at = data.submitted_at\n  }\nend",
                "purpose": "Submits PRD for stakeholder approval with completeness validation"
              },
              {
                "start_line": 198,
                "end_line": 216,
                "code": "function M.get_approval_status()\n  local data = get_workflow_data()\n  local stakeholder_module = require(\"test_b.stakeholder\")\n\n  local status = {}\n\n  for stakeholder_id, approval in pairs(data.approvals) do\n    local stakeholder = stakeholder_module.get_stakeholder(stakeholder_id)\n    table.insert(status, {\n      stakeholder_id = stakeholder_id,\n      stakeholder_name = stakeholder and stakeholder.name or \"Unknown\",\n      approval_status = approval.status,\n      requested_at = approval.requested_at,\n      responded_at = approval.responded_at\n    })\n  end\n\n  return status\nend",
                "purpose": "Returns approval status for all stakeholders with timestamps"
              },
              {
                "start_line": 219,
                "end_line": 233,
                "code": "function M.is_prd_approved()\n  local data = get_workflow_data()\n\n  if not data.approvals or vim.tbl_count(data.approvals) == 0 then\n    return false\n  end\n\n  for _, approval in pairs(data.approvals) do\n    if approval.status ~= \"approved\" then\n      return false\n    end\n  end\n\n  return true\nend",
                "purpose": "Checks if PRD is fully approved by all required stakeholders"
              }
            ]
          }
        ],
        "notes": "Implementation complete. Full PRD workflow with 9-item checklist management, section status tracking, completeness validation, and multi-stakeholder approval workflow."
      },
      "expectation": "The system provides complete PRD workflow management from checklist initialization through stakeholder approval",
      "prediction": "All tests will pass with proper checklist initialization, section tracking, validation, approval workflow, and stakeholder integration",
      "explanation": [
        "initialize_prd_checklist() implemented at lua/test_b/prd_workflow.lua:45-81 - Creates 9-item checklist with all required PRD sections",
        "update_section_status(section, status) implemented at lua/test_b/prd_workflow.lua:84-108 - Tracks completion status for 7 PRD sections with timestamps",
        "validate_prd_completeness() implemented at lua/test_b/prd_workflow.lua:111-159 - Validates all sections, requirements, and risks are complete",
        "submit_for_approval(stakeholder_ids) implemented at lua/test_b/prd_workflow.lua:162-195 - Initiates approval workflow with validation check",
        "get_approval_status() implemented at lua/test_b/prd_workflow.lua:198-216 - Returns approval status from all stakeholders",
        "is_prd_approved() implemented at lua/test_b/prd_workflow.lua:219-233 - Returns true only when all stakeholders have approved"
      ],
      "status": "pass",
      "design_spec_quote": {
        "selected_text": "Once requirements are gathered, update this PRD to include: Clear problem statement and business context, detailed functional requirements (REQ-1 through REQ-n), specific non-functional requirements with measurable criteria."
      }
    }
  ],
  "summary": {
    "total_scenarios": 6,
    "complexity": "high",
    "estimated_time": "120 minutes"
  }
}
